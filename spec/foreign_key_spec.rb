require File.expand_path(File.dirname(__FILE__) + '/spec_helper')

describe "Foreign Key" do

  let(:migration) { ::ActiveRecord::Migration }

  context "created with table" do
    before(:all) do
      define_schema(:auto_create => true) do
        create_table :users, :force => true do |t|
          t.string :login
        end
        create_table :comments, :force => true do |t|
          t.integer :user_id
          t.foreign_key :user_id, :users, :id
        end
      end
      class User < ::ActiveRecord::Base ; end
      class Comment < ::ActiveRecord::Base ; end
    end

    it "should report foreign key constraints" do
      Comment.foreign_keys.collect(&:column_names).flatten.should == [ "user_id" ]
    end

    it "should report reverse foreign key constraints" do
      User.reverse_foreign_keys.collect(&:column_names).flatten.should == [ "user_id" ]
    end

  end

  if ::ActiveRecord::VERSION::MAJOR.to_i >= 4
    context "with modifications to SQL generated by upstream visit_TableDefinition" do
      before(:each) do
        class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
          alias_method :visit_TableDefinition_without_schema_plus_orig, :visit_TableDefinition_without_schema_plus
          def visit_TableDefinition_without_schema_plus(o)
            create_sql = visit_TableDefinition_without_schema_plus_orig(o)
            last_chunk = ") #{o.options}"

            unless create_sql.end_with?(last_chunk)
              raise "Internal Error: Can't find '#{last_chunk}' at end of '#{create_sql}' - Rails internals have changed!"
            end

            create_sql[create_sql.size - last_chunk.size + 1, 0] = ' '
            create_sql
          end
        end
      end

      after(:each) do
        class ActiveRecord::ConnectionAdapters::AbstractAdapter::SchemaCreation
          alias_method :visit_TableDefinition_without_schema_plus, :visit_TableDefinition_without_schema_plus_orig
          remove_method :visit_TableDefinition_without_schema_plus_orig
        end
      end

      it "raises an exception when attempting to create a table" do
        expect {
          define_schema(:auto_create => true) do
            create_table :users, :force => true do |t|
              t.string :login
            end
            create_table :comments, :force => true do |t|
              t.integer :user_id
              t.foreign_key :user_id, :users, :id
            end
          end
        }.to raise_error(RuntimeError, /Internal Error: Can't find.*Rails internals have changed/)
      end
    end
  end

  context "modification" do

    before(:all) do
      define_schema(:auto_create => false) do
        create_table :users, :force => true do |t|
          t.string :login
          t.datetime :deleted_at
        end

        create_table :posts, :force => true do |t|
          t.text :body
          t.integer :user_id
          t.integer :author_id
        end

        create_table :comments, :force => true do |t|
          t.text :body
          t.integer :post_id
          t.foreign_key :post_id, :posts, :id
        end
      end
      class User < ::ActiveRecord::Base ; end
      class Post < ::ActiveRecord::Base ; end
      class Comment < ::ActiveRecord::Base ; end
    end

    if SchemaPlusHelpers.sqlite3?

      it "raises an exception when attempting to add" do
        expect { 
          add_foreign_key(:posts, :author_id, :users, :id, :on_update => :cascade, :on_delete => :restrict)
        }.to raise_error(NotImplementedError)
      end

      it "raises an exception when attempting to remove" do
        expect { 
          remove_foreign_key(:posts, "dummy")
        }.to raise_error(NotImplementedError)
      end

    else

      context "when is added", "posts(author_id)" do

        before(:each) do 
          add_foreign_key(:posts, :author_id, :users, :id, :on_update => :cascade, :on_delete => :restrict)
        end

        after(:each) do
          fk = Post.foreign_keys.detect { |fk| fk.column_names == %w[author_id] }
          remove_foreign_key(:posts, fk.name)
        end

        it "references users(id)" do
          Post.should reference(:users, :id).on(:author_id)
        end

        it "cascades on update" do
          Post.should reference(:users).on_update(:cascade)
        end

        it "restricts on delete" do
          Post.should reference(:users).on_delete(:restrict)
        end

        it "is available in Post.foreign_keys" do
          Post.foreign_keys.collect(&:column_names).should include(%w[author_id])
        end

        it "is available in User.reverse_foreign_keys" do
          User.reverse_foreign_keys.collect(&:column_names).should include(%w[author_id])
        end

      end

      context "when is dropped", "comments(post_id)" do

        let(:foreign_key_name) { fk = Comment.foreign_keys.detect { |definition| definition.column_names == %w[post_id] } and fk.name }

        before(:each) do
          remove_foreign_key(:comments, foreign_key_name)
        end

        after(:each) do
          add_foreign_key(:comments, :post_id, :posts, :id)
        end

        it "doesn't reference posts(id)" do
          Comment.should_not reference(:posts).on(:post_id)
        end

        it "is no longer available in Post.foreign_keys" do
          Comment.foreign_keys.collect(&:column_names).should_not include(%w[post_id])
        end

        it "is no longer available in User.reverse_foreign_keys" do
          Post.reverse_foreign_keys.collect(&:column_names).should_not include(%w[post_id])
        end

      end

      context "when referencing column and column is removed" do

        let(:foreign_key_name) { Comment.foreign_keys.detect { |definition| definition.column_names == %w[post_id] }.name }

        it "should remove foreign keys" do
          remove_foreign_key(:comments, foreign_key_name)
          Post.reverse_foreign_keys.collect { |fk| fk.column_names == %w[post_id] && fk.table_name == "comments" }.should be_empty
        end

      end

      context "when table name is a reserved word" do
        before(:each) do
          migration.suppress_messages do
            migration.create_table :references, :force => true do |t|
              t.integer :post_id, :foreign_key => false
            end
          end
        end

        it "can add, detect, and remove a foreign key without error" do
          migration.suppress_messages do
            expect {
              migration.add_foreign_key(:references, :post_id, :posts, :id)
              foreign_key = migration.foreign_keys(:references).detect{|definition| definition.column_names == ["post_id"]}
              migration.remove_foreign_key(:references, foreign_key.name)
            }.to_not raise_error
          end
        end
      end

    end
  end

  protected
  def add_foreign_key(*args)
    migration.suppress_messages do
      migration.add_foreign_key(*args)
    end
    User.reset_column_information
    Post.reset_column_information
    Comment.reset_column_information
  end

  def remove_foreign_key(*args)
    migration.suppress_messages do
      migration.remove_foreign_key(*args)
    end
    User.reset_column_information
    Post.reset_column_information
    Comment.reset_column_information
  end

end
